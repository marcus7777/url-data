<link rel="import" href="../polymer/polymer.html">
<script src="../jsurl/lib/jsurl.js" type="application/javascript"></script>
<script>
/*
 * `<url-data></url-data>` A way to send data through URL automatically eliminating repeating data
 * @demo demo.html
 */
  Polymer({
    is: "url-data",
    properties: {
      data: {notify: true},
      string: {notify: true, type: String},
      compressed: {notify: true, type: Object},
      letters: {type:String, value: "taoinshrdcumwfgypbvkjxqz"},
      numbers: {type:String, value: "0123456789."},
      cycles: {type:Number, value: 32},
      trys: {type:Number, value: 100},
      _countUp: {type:Array, value: [0,0,0]},
      _chrList: {computed: "getChrList(letters,numbers)"},
      _tryKeys: {computed: "getTryKeys(_chrList)"},
      dataFromString: {computed: "decode(string)"},
      stringFromData: {computed: "encode(data)"}
    },
    findAkey: function(text) {
      if (this._countUp[1] === 0 && this._countUp[2] === 0) {
        for (; this._countUp[0] < this._tryKeys.length; this._countUp[0]++) {
          if (text.indexOf(this._tryKeys[this._countUp[0]]) === -1) {
            return this._tryKeys[this._countUp[0]]
          }
        }
        this._countUp[0] = 0
      }
      if (this._countUp[2] === 0) {
        for (; this._countUp[0] < this._tryKeys.length; this._countUp[0]++) {
          for (; this._countUp[1] < this._tryKeys.length; this._countUp[1]++) {
            if (text.indexOf(this._tryKeys[this._countUp[0]] + this._tryKeys[this._countUp[1]]) === -1) {
              return this._tryKeys[this._countUp[0]] + this._tryKeys[this._countUp[1]]
            }
          }
          this._countUp[1] = 0
        }
        this._countUp[0] = 0
      }
      for (; this._countUp[0] < this._tryKeys.length; this._countUp[0]++) {
        for (; this._countUp[1] < this._tryKeys.length; this._countUp[1]++) {
          for (; this._countUp[2] < this._tryKeys.length; this._countUp[2]++) {
            if (text.indexOf(this._tryKeys[this._countUp[0]] + this._tryKeys[this._countUp[1]] + this._tryKeys[this._countUp[2]]) === -1) {
              return this._tryKeys[this._countUp[0]] + this._tryKeys[this._countUp[1]] + this._tryKeys[this._countUp[2]]
            }
          }
          this._countUp[2] = 0
        }
        this._countUp[1] = 0
      }
      this._countUp[0] = 0
    },
    lastKey: function(keys) {
      var keyLength = keys.reduce(function(a, b) {
        return a.length > b.length ? a : b;
      }).length
      if (keyLength === 3) {
        for (; this._countDown[0] > -1; this._countDown[0]--) {
          for (; this._countDown[1] > -1; this._countDown[1]--) {
            for (; this._countDown[2] > -1; this._countDown[2]--) {
              if (keys.indexOf(this._tryKeys[this._countDown[0]] + this._tryKeys[this._countDown[1]] + this._tryKeys[this._countDown[2]]) !== -1) {
                return this._tryKeys[this._countDown[0]] + this._tryKeys[this._countDown[1]] + this._tryKeys[this._countDown[2]]
              }
            }
            this._countDown[2] = this._tryKeys.length
          }
          this._countDown[1] = this._tryKeys.length
        }
        this._countDown[0] = this._tryKeys.length
      } else if (keyLength === 2) {
        for (; this._countDown[0] > -1; this._countDown[0]--) {
          for (; this._countDown[1] > -1; this._countDown[1]--) {
            if (keys.indexOf(this._tryKeys[this._countDown[0]] + this._tryKeys[this._countDown[1]]) !== -1) {
              return this._tryKeys[this._countDown[0]] + this._tryKeys[this._countDown[1]]
            }
          }
          this._countDown[1] = this._tryKeys.length
        }
        this._countDown[0] = this._tryKeys.length
      } else {
        if (keys.length === 1 && keys[0] === "e") {
          return false
        } else {
          this._countDown[0] = this._tryKeys.length 
          for (; this._countDown[0] > -1; this._countDown[0]--) {
            if (keys.indexOf(this._tryKeys[this._countDown[0]]) !== -1) {
              return this._tryKeys[this._countDown[0]]
            }
          }
          this._countDown[0] = this._tryKeys.length
        }
      }
      return false
    },
    getIndexKey: function(tryKeys) {
      return [tryKeys.length, tryKeys.length, tryKeys.length]
    },
    getTryKeys: function(chrList) {
      return chrList.split("").reverse()
    },
    getChrList: function(letters, numbers) {
      return letters + letters.toUpperCase() + numbers
    },
    decode: function(theInput) {
      if (theInput) {
        var theOutput
        // this._countDown = this.getIndexKey(this._tryKeys) // reset count down 
        try { // the new way
          data = JSURL.parse(theInput)
        } catch (e) { // try the old way
          data = JSON.parse(decodeURIComponent(theInput)) 
        }
        if (data.e) {
          do {
            this._countDown = this.getIndexKey(this._tryKeys) // needs fixing /\
            theLastKey = this.lastKey(Object.keys(data))
            if (theLastKey) {
              data.e = data.e.split(theLastKey).join(data[theLastKey])
              delete(data[theLastKey])
            }
          } while (theLastKey)
          if (Object.keys(data).length === 1) {
            try {
              theOutput = JSON.parse(data.e)
            } catch (e) {
              theOutput = data.e
            }
            if (JSON.stringify(theOutput) !== JSON.stringify(this.data)) {
              this.set("data", theOutput)
            }
            return theOutput
          } else {
            console.log("error", data)
          }
        } else {
          if (JSON.stringify(data) !== JSON.stringify(this.data)) {
            this.set("data", data)
          }
          return data
        }
      } else {
        return
      }
    },
    encode: function(theInput, size, cycles) {
      if (!this.string || JSON.stringify(theInput) !== JSON.stringify(this.decode(this.string))) {
        if (cycles === undefined) {
          cycles = this.cycles
        }
        if (!size) {
          size = JSURL.stringify(theInput).length
          this._countUp = [0,0,0]
        }
        if (typeof theInput === "string") {
          var input = "" + theInput
          var output = {e: theInput}
        } else {
          if (theInput.e) {
            var input = "" + theInput.e
            var output = JSON.parse(JSON.stringify(theInput))
          } else {
            var input = JSON.stringify(theInput)
            var output = {e:JSON.stringify(theInput)}
          }
        }
        if (size < 50) { 
          if (JSURL.stringify(theInput) !== this.string) {
            this.set("string", JSURL.stringify(theInput))
          }
          return JSURL.stringify(theInput) // No need to reduce
        } else {
          var reg = /(?=((..+)(?:..*?\2)+))/g
        }
        var sub = "" //somewhere to stick temp results
        var maxstr = "" // our maximum length repeated string
        var maxSaving = 2
        var key = this.findAkey(input)
        var smallSavingTestLimit = +this.trys
        
        reg.lastIndex = 0
        if (input.length > 2500) {
          var startSlice = Math.floor((input.length - 2500) * (cycles / this.cycles))
          var testSlice = input.slice(startSlice, startSlice + 2500)
        } else {
          var testSlice = input
        }
        var inputSize = JSURL.stringify(input).length
        sub = reg.exec(testSlice) // find the first repeated string
        while (!(sub == null)) {
          var saving = inputSize - JSURL.stringify("{" + key + "}:'" + sub[2] + "'," + input.split(sub[2]).join(key)).length
          if (saving > maxSaving) {
            maxSaving = +saving
            maxstr = sub[2]
            if (maxSaving > ((inputSize + 500) / 10)) {
              break
            }
            smallSavingTestLimit = +this.trys
          } else {
            if (smallSavingTestLimit-- < 1) {
              break
            }
          }
          sub = reg.exec(testSlice)
          reg.lastIndex++; // start searching from the next position
        }
        if (key && maxstr) {
          output[key] = maxstr
          output.e = input.split(maxstr).join(key)
        }
        if (JSURL.stringify(output).length + 2 < JSURL.stringify(theInput).length && cycles > 0) {
          console.log("cycles left",cycles)
          console.log("Saving", maxSaving)
          return this.encode(output, size, cycles-1)
        } else {
          if (JSURL.stringify(output) !== this.string) {
            this.set("compressed", output)
            this.set("string", JSURL.stringify(output))
          }
          console.log("Total saving",size - JSURL.stringify(output).length)
          return JSURL.stringify(output)
        }
      }
    }
  })
</script>
